{
    "contents" : "---\ntitle: \"learn_Rcurl\"\nauthor: \"daigazi\"\ndate: \"Friday, November 27, 2015\"\noutput: html_document\n---\n```{r golbal-optional,message=FALSE,echo=FALSE,warning=FALSE}\nlibrary(knitr)\nopts_knit$set(cache=T,eval=F,highlight=TRUE)\n```\n\n# http协议\n\n\n## 1.什么是http\n>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是互联网上应用最为广泛的一种网络协议。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。\n>HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。\n\n![alt text](http1.png)\n\n如上图所示http协议是联通服务器与客户端之间的一个协议，在连接的过程，客户端首先与服务器`建立连接`，接着`发出请`求，服务器根据接受的请求作出相应的`响应信息`，最终关闭连接。  \n### 1.http1.0 和http1.1 版本之间的差异\n\n>超文本传输协议已经演化出了很多版本，它们中的大部分都是向下兼容的。在 RFC 2145 中描述了HTTP版本号的用法。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。\n\n### 2. 0.9协议\n>已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。  \n\n### 3. HTTP/1.0 协议 \n>这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。  \n\n### 4. HTTP/1.1 协议 \n>持久连接被默认采用，并能很好地配合代理服务器工作。还支持以渠道方式在同时发送多个请求，以便降低线路负载，提高传输速度。\nHTTP/1.1相较于HTTP/1.0协议的区别主要体现在： \n\n- 缓存处理\n- 带宽优化及网络连接的使用\n- 错误通知的管理\n- 消息在网络中的发送\n- 互联网地址的维护\n- 安全性及完整性  \n\n## 2.url基本格式\n\n基本格式 scheme://host{:port#]/path/.../[?query-string][#anchor]\n\n- scheme: 指定底层使用的协议（例如：http、https、ftp）\n- host http服务器的IP地址或者域名\n- port# http服务器的默认端口是80 ，这种情况下端口号可以被省略\n- path 访问资源的路径\n- query-string  发送给http服务器的数据\n- anchor-  锚\n\n比如：http://login.sina.com.cn/signup/signin.php?entry=sso  \n- http:// 协议  \n- login.sian.com.cn 域名  \n- signup/signin.php 路径  \n- ?entry=sso 附送给http服务器的数据  \n- ?之后是query ，提交给服务器的信息，等待服务器返回信息  \n\n\n## 请求request\n\n* Method/path-to -resource /HTTP Version-number  #请求行  \n* header-Name-1 :value    #请求报头  \n* header-name-2 :value    #请求报头  \n* optional request body   # 消息正文  \n\n- Method表示请求方法，比如\"GET\",\"POST\",'HEAD',\"PUT\",\"DELETE\",\"OPTIONS\",\"TRACE\",\"CONNECT\"\n        Method的方法是区分大小写\n- path-to-resource 表示请求的资源\n- HTTP Version-number 表示http协议的版本号\n\n### 请求报头\n\n- Host 服务器的地址\n- Accept 浏览器可以接受的类型,一般是HTML,或者用通用符*来表示，表示接受所有的类型\n- Accept_encoding  不是指字符编码，是浏览器声明编码方法，主要是指压缩方法\n- Aceept-language  接受的语言，一般是em-us或者zh \n- User-agent  浏览器或者系统版面\n- Cookie\n- Referer\n- Connection\n\n## 响应response\n\n* 状态行、消息报头、响应正文\n  * http/vesion-number  status code  message \n  * Header-Name-1:value\n  * Header-Name-2:value\n  * Optional Response body\n1. HTTP/vesion-number 表示HTTP协议的版本号\n2. status-code 和 message表示状态码以及状态信息\n\n# RCurl三大函数\n\n## 1.getURL()\n### url.exists()  \n\n查看网址是否存在\n```{r url.exists}\nlibrary(RCurl)\nurl=\"http://www.baidu.com\"\nurl.exists(url)\nurl.exists(\"fttp:baidu.com\") #FALSE\n```\n\n\n### debugGatherer()\n```{r debugGatherer}\nurl=\"http://www.baidu.com\"\nd=debugGatherer()\nd \ntemp=getURL(url,debugfunction=d$update,verbose=T) #verbose=T 叠加信息\nd  \nd$value()\ncat(d$value()[1]) #服务器地址以及端口号\ncat(d$value()[2]) #服务器返回的头信息\ncat(d$value()[3]) #提交服务器返回的头信息\n\n\n```\n\n- 再次运行下上一句函数，返回的信息会叠加\n```{r}\ntemp=getURL(url,debugfunction=d$update,verbose=T) #verbose=T 叠加信息\ncat(d$value()[1]) #服务器地址以及端口号\ncat(d$value()[2]) #服务器返回的头信息\ncat(d$value()[3]) #提交服务器返回的头信息\n```\n\n- 如果verbose=F的话不会叠加\n```{r}\ntemp=getURL(url,debugfunction=d$update,verbose=F) \ncat(d$value()[1]) #服务器地址以及端口号\ncat(d$value()[2]) #服务器返回的头信息\ncat(d$value()[3]) #提交服务器返回的头信\n```\n\n- d$reset 重置d里的值\n```{r}\nd$reset()\n```\n\n\n\n## 2.getForm()\n\n## 3.postForm()",
    "created" : 1448595488320.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "428695836",
    "id" : "9EE2FC69",
    "lastKnownWriteTime" : 1448614572,
    "path" : "D:/Git/stock/learn_Rcurl.Rmd",
    "project_path" : "learn_Rcurl.Rmd",
    "properties" : {
        "tempName" : "Untitled3"
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}