{
    "contents" : "---\ntitle: \"XML\"\nauthor: \"daigazi\"\ndate: \"2015年11月4日\"\noutput: html_document\n---\n\n```{r,echo=F}\nlibrary(knitr)\nopts_chunk$set(comment=NA, fig.width=6, fig.height=6,cache = TRUE)\n```\n\n# XML\n\n```{r,XMLl,eval=T,echo=TRUE,highlight=TRUE}\nlibrary(XML)\nfileUrl <- \"http://www.w3school.com.cn/example/xmle/simple.xml\"\ndoc <- xmlTreeParse(fileUrl,useInternal=TRUE) \nrootNode <- xmlRoot(doc) #得到XML节点\nxmlName(rootNode) \nnames(rootNode) \nrootNode[[1]]  #第一个names(rootNOde)标签里<food>的东西\nrootNode[[1]][[1]] #标签内第一行\nrootNode[[1]][[2]] #第二行\nrootNode[[2]]\nxmlSApply(X = rootNode,FUN = xmlValue) #对XML节点，利用xmlValue递归遍历整个文本，取标签里的值，最后用$连接各个值\n#X          the XMLNode on whose children the regular apply or sapply is to be performed\n#FUN        the function to apply to each child node. This is passed directly to the relevant apply function.\n\n#...\tadditional arguments to be given to each invocation of FUN. This is passed directly to the relevant apply function.\n\n```\n\n# XPath\n* /node Top level node\n* //node Node at any level\n* node[@attr-name] Node with an attribute name\n* node[@attr-name='bob'] Node with attribute name attr-name='bob'\n* Information from: [linked phrase](http://www.stat.berkeley.edu/~statcur/Workshop2/Presentations/XML.pdf)\n```{r,Xpath,eval=T,echo=TRUE,highlight=TRUE}\nlibrary(XML)\nfileUrl <- \"http://www.w3school.com.cn/example/xmle/simple.xml\"\ndoc <- xmlTreeParse(fileUrl,useInternal=TRUE) \nrootNode <- xmlRoot(doc) #得到XML节点\nxpathSApply(rootNode,\"/food\",xmlValue)  #顶层节点\nxpathSApply(rootNode,\"//name\",xmlValue) #次一层节点\nxpathSApply(rootNode,\"//price\",xmlValue) #次一层节点\nxpathSApply(doc,\"//food[@class='price']\",xmlValue) #对文档操作而不是节点文档，次一层节点,为什么返回的是空列表\nxpathSApply(doc,\"//food[@class]\",xmlValue) #次一层节点\n```\n这是因为此网页里food标签下无class属性，[此链接](http://my.oschina.net/u/1431368/blog/305311)所示的，就可以用。若上述网页里是<food class=\"12\">noddle </food>这个形式，那么就xpathSApply(doc,\"//food[@class]\",xmlValue) 就可以取到\"noodle\"\n```{r}\nfileUrl <- \"http://espn.go.com/nfl/team/_/name/bal/baltimore-ravens\"\ndoc <- htmlTreeParse(fileUrl,useInternal=TRUE)\nscores <- xpathSApply(doc,\"//li[@class='score']\",xmlValue) #对文档操作，而不是节点文件\nteams <- xpathSApply(doc,\"//li[@class='team-name']\",xmlValue)\nscores\nteams\n```\n\n# XPath如东方财富网\n利用xpathSApply函数读入东方财富网的股票信息\n```{r,eval=F,echo=T,highlight=TRUE,error=TRUE}\nlibrary(XML)\nfileUrl <- \"http://quote.eastmoney.com/stocklist.html\" \ndoc <- htmlTreeParse(fileUrl,useInternal=TRUE,encoding = \"GBK\") #报错，这个网站出现nbsp（不间断间隔）、开始和结束标签不匹配等问题\nrootNode <- xmlRoot(doc) #得到XML节点\nxmlName(rootNode) \nnames(rootNode) \n```\n\n# XPath读取同花顺网页数据\n利用xpathSApply函数读入同花顺股票信息\n\n```{r,eval=F,echo=T,highlight=TRUE,error=TRUE}\nlibrary(XML)\nfileUrl <- \"http://bbs.10jqka.com.cn/codelist.html\"\ndoc <- htmlTreeParse(fileUrl,useInternal=TRUE,encoding = \"GBK\")  #注意是htmlTreeParse\nrootnode=xmlRoot(doc)\nli=xpathSApply(doc,\"//li\",xmlValue) #发现读取回来的文字是乱码\nli_vec=unlist(li)\nli_vec=iconv(x = li_vec,from = \"gbk\",to = \"UTF-8\") #x 字符串向量，还是乱码\n# library(stringi)\n# enc=stri_enc_detect(li_vec)  #检测文档编码\n# li_vecstri_encode(li_vec,enc,\"UTF-8\")  #把文档转换成UTF-8格式\nwrite.csv( li_vec,\"stockname.csv\",fileEncoding=\"GBK\")\n```\n使用Rcurl::getUrl读入数据后再用htmlTreeParse分析，重点是在读入数据的时候把数据类型转换\n\n```{r,error=TRUE}\nlibrary(XML)\nlibrary(RCurl)\nfileUrl <- \"http://bbs.10jqka.com.cn/codelist.html\"\ndoc=getURL(url = fileUrl,.encoding = \"GBK\")\nclass(doc) #发现doc是字符串，可以使用iconv函数转换成UTF-8格式\ndoc=iconv(x = doc,from = \"GBK\",to = \"UTF-8\")\ndoc=xmlTreeParse(file = doc,useInternalNodes = T) #报错，标签不匹配等\nrootnode=xmlRoot(doc) #直接取节点,因为doc是字符串不可行\n#查看xmlRoot的方法，可以发现没有xmlRoot.character这个方法\n\n```\n\n```{r,error=TRUE}\nlibrary(XML)\nlibrary(RCurl)\nurl=\"https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Frestaurants.xml\"\nxData=xmlTreeParse( file = url,useInternal=TRUE) #报错\n#把url的https改成http就可以了\nurl1=\"http://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Frestaurants.xml\"\ndoc=xmlTreeParse( file = url1,useInternal=TRUE)  \nrootnode=xmlRoot(doc)\nzipcode=xpathSApply(doc,\"//zipcode\",xmlValue)\nclass(zipcode);typeof(zipcode)\nzipcode[zipcode==\"21231\"]\n```\n\n## 另一种方式\n```{r,error=TRUE}\nlibrary(XML)\nlibrary(RCurl)\nurl1=\"https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Frestaurants.xml\"\nxData <- getURL(url1) #载入数据\nurl=\"http://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Frestaurants.xml\"\nxData <- getURL(url) #Changing https to http also seems to work.\ndoc=xmlTreeParse( file = xData,useInternal=TRUE) #报错，这个网站出现nbsp（不间断间隔）、开始和结束标签不匹配等问题\nrootnode=xmlRoot(doc)\nzipcode=xpathSApply(doc,\"//zipcode\",xmlValue)\nclass(zipcode);typeof(zipcode)\nzipcode[zipcode==21231,]\n\n```\n\n## xml包几个常用的函数（可以在xpathSApply中应用）\n\n```{r}\nfileurl <- \"http://www.w3school.com.cn/example/xmle/simple.xml\"\nweb=xmlTreeParse(file = fileurl,trim = T,useInternal=TRUE,encoding = \"GBK\")\n  #html网页用htmlTreeParse,xml用xmlTreeParse\nnode=xmlRoot(web) #获取高水平的XML节点\nxmlName(node)  #获取顶层标签名\nxmlAttrs(node)\n```\n \n### XML按层次取值\n```{r}\n fileName <- system.file(\"exampleData\", \"mtcars.xml\", package=\"XML\") \n  doc <- xmlTreeParse(fileName)\n  node=xmlRoot(doc)  #做标签树\n  xmlName(node)  #顶层标签<dataset>\n  xmlAttrs(node) #顶层标签<dataset>里的值，在<dataset name=\"mtcars\" numRecords=\"32\" source=\"R Project\">中返回字符串 \"mtcars\"        \"32\" \"R Project\" \n  xmlGetAttr(node=node,name=\"numRecords\")  #提取某个子属性的属性值\n  xmlChildren(node)  #次一层标签\n  xmlSize(xmlChildren(node))  #list的长度\n  xmlChildren(node)[[1]]  #次一层标签的第一个子标签\n  tmp=xmlChildren(node)[[20]]  #次一层标签的第20个子标签\n  xmlGetAttr(tmp,\"id\")  #属性id的值\n  xmlValue(tmp)  #值\n  xmlSize(tmp)  #list的长度\n  xmlChildren(xmlChildren(node)[[1]])  #次次层标签\n\n\n```\n### XML按标签取值\n* /node 顶层标签\n* //node 任意层标签\n* node[@attr-name] 取节点下某个属性的\n* node[@attr-name='bob'] 取节点下某个属性等于bob的值\n```{r}\n fileName <- system.file(\"exampleData\", \"mtcars.xml\", package=\"XML\") \n  doc <- xmlTreeParse(fileName)\n  node=xmlRoot(doc)\n  getNodeSet(doc = node,path = \"/dataset\")\n  getNodeSet(doc = node,path = \"/dataset//record\")\n  getNodeSet(doc = node,path = \"//record\")\n  getNodeSet(doc = node,path = \"//variable\") #可以直接取第三层的\n  getNodeSet(doc = node,path = \"/dataset//record[@id]\")\n  getNodeSet(doc = node,path = \"/dataset//record[@id='Lotus Europa']\")\n```\n",
    "created" : 1448862756613.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3117303846",
    "id" : "A923AA40",
    "lastKnownWriteTime" : 1448969468,
    "path" : "D:/Git/stock/learnXML.Rmd",
    "project_path" : "learnXML.Rmd",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}