{
    "contents" : "Introduction to R6 classes\n\nR6 classes\nBasics\nPrivate members\nActive bindings\nInheritance\nFields containing reference objects\nPortable and non-portable classes\nUsing self and <<-\n        Other topics\nAdding members to an existing class\nPrinting R6 objects to the screen\nSummary\nThe R6 package provides a type of class which is similar to R’s standard reference classes, but it is more efficient and doesn’t depend on S4 classes and the methods package.\nR6 classes\n\nR6 classes are similar to R’s standard reference classes, but are lighter weight, and avoid some issues that come along with using S4 classes (R’s reference classes are based on S4). For more information about speed and memory footprint, see the Performance vignette.\nUnlike many objects in R, instances (objects) of R6 classes have reference semantics. R6 classes also support:\n        public and private methods\nactive bindings\ninheritance (superclasses) which works across packages\nWhy the name R6? When R’s reference classes were introduced, some users, following the names of R’s existing class systems S3 and S4, called the new class system R5 in jest. Although reference classes are not actually called R5, the name of this package and its classes takes inspiration from that name.\nThe name R5 was also a code-name used for a different object system started by Simon Urbanek, meant to solve some issues with S4 relating to syntax and performance. However, the R5 branch was shelved after a little development, and it was never released.\nBasics\n\nHere’s how to create a simple R6 class. The public argument is a list of items, which can be functions and fields (non-functions). Functions will be used as methods.\nlibrary(R6)\n\nPerson <- R6Class(\"Person\",\n                  public = list(\n                          name = NA,\n                          hair = NA,\n                          initialize = function(name, hair) {\n                                  if (!missing(name)) self$name <- name\n                                  if (!missing(hair)) self$hair <- hair\n                                  self$greet()\n                          },\n                          set_hair = function(val) {\n                                  self$hair <- val\n                          },\n                          greet = function() {\n                                  cat(paste0(\"Hello, my name is \", self$name, \".\\n\"))\n                          }\n                  )\n)\nTo instantiate an object of this class, use $new():\n        ann <- Person$new(\"Ann\", \"black\")\n#> Hello, my name is Ann.\nann\n#> <Person>\n#>   Public:\n#>     greet: function\n#>     hair: black\n#>     initialize: function\n#>     name: Ann\n#>     set_hair: function\nThe $new() method creates the object and calls the initialize() method, if it exists.\nInside methods of the class, self refers to the object. Public members of the object (all you’ve seen so far) are accessed with self$x, and assignment is done with self$x <- y. Note that by default, self is required to access members, although for non-portable classes which we’ll see later, it is optional.\nOnce the object is instantiated, you can access values and methods with $:\n        ann$hair\n#> [1] \"black\"\nann$greet()\n#> Hello, my name is Ann.\nann$set_hair(\"red\")\nann$hair\n#> [1] \"red\"\nImplementation note: The R6 object is basically an environment with the public members in it. The self object is bound in that environment, and is simply a reference back to that environment.\nPrivate members\n\nIn the previous example, all the members were public. It’s also possible to add private members:\n        Queue <- R6Class(\"Queue\",\n                         public = list(\n                                 initialize = function(...) {\n                                         for (item in list(...)) {\n                                                 self$add(item)\n                                         }\n                                 },\n                                 add = function(x) {\n                                         private$queue <- c(private$queue, list(x))\n                                         invisible(self)\n                                 },\n                                 remove = function() {\n                                         if (private$length() == 0) return(NULL)\n                                         # Can use private$queue for explicit access\n                                         head <- private$queue[[1]]\n                                         private$queue <- private$queue[-1]\n                                         head\n                                 }\n                         ),\n                         private = list(\n                                 queue = list(),\n                                 length = function() base::length(private$queue)\n                         )\n        )\n\nq <- Queue$new(5, 6, \"foo\")\nWhereas public members are accessed with self, like self$add(), private members are accessed with private, like private$queue.\nThe public members can be accessed as usual:\n        # Add and remove items\n        q$add(\"something\")\nq$add(\"another thing\")\nq$add(17)\nq$remove()\n#> [1] 5\nq$remove()\n#> [1] 6\nHowever, private members can’t be accessed directly:\n        q$queue\n#> NULL\nq$length()\n#> Error: attempt to apply non-function\nUnless there is a compelling reason otherwise, methods should return self (invisibly) because it makes them chainable. For example, the add() method returns self so you can chain them together:\n        q$add(10)$add(11)$add(12)\nOn the other hand, remove() returns the value removed, so it’s not chainable:\n        q$remove()\n#> [1] \"foo\"\nq$remove()\n#> [1] \"something\"\nq$remove()\n#> [1] \"another thing\"\nq$remove()\n#> [1] 17\nImplementation note: When private members are used, the public environment is a child of the private environment, and the private object points to the private environment. Although public and private methods are bound (that is, they can be found) in their respective environments, the enclosing environment for all of those methods is the public environment. This means that private methods “run in” the public environment, so they will find public objects without needing an explicit self$xx.\nActive bindings\n\nActive bindings look like fields, but each time they are accessed, they call a function. They are always publicly visible.\nNumbers <- R6Class(\"Numbers\",\n                   public = list(\n                           x = 100\n                   ),\n                   active = list(\n                           x2 = function(value) {\n                                   if (missing(value)) return(self$x * 2)\n                                   else self$x <- value/2\n                           },\n                           rand = function() rnorm(1)\n                   )\n)\n\nn <- Numbers$new()\nn$x\n#> [1] 100\nWhen an active binding is accessed as if reading a value, it calls the function with value as a missing argument:\n        n$x2\n#> [1] 200\nWhen it’s accessed as if assigning a value, it uses the assignment value as the value argument:\n        n$x2 <- 1000\nn$x\n#> [1] 500\nIf the function takes no arguments, it’s not possible to use it with <-:\n        n$rand\n#> [1] 0.2648\nn$rand\n#> [1] 2.171\nn$rand <- 3\n#> Error: unused argument (quote(3))\nImplementation note: Active bindings are bound in the public environment. The enclosing environment for these functions is also the public environment.\nInheritance\n\nOne R6 class can inherit from another. In other words, you can have super- and sub-classes.\nSubclasses can have additional methods, and they can also have methods that override the superclass methods. In this example of a queue that retains its history, we’ll add a show() method and override the remove() method:\n        # Note that this isn't very efficient - it's just for illustrating inheritance.\n        HistoryQueue <- R6Class(\"HistoryQueue\",\n                                inherit = Queue,\n                                public = list(\n                                        show = function() {\n                                                cat(\"Next item is at index\", private$head_idx + 1, \"\\n\")\n                                                for (i in seq_along(private$queue)) {\n                                                        cat(i, \": \", private$queue[[i]], \"\\n\", sep = \"\")\n                                                }\n                                        },\n                                        remove = function() {\n                                                if (private$length() - private$head_idx == 0) return(NULL)\n                                                private$head_idx <<- private$head_idx + 1\n                                                private$queue[[private$head_idx]]\n                                        }\n                                ),\n                                private = list(\n                                        head_idx = 0\n                                )\n        )\n\nhq <- HistoryQueue$new(5, 6, \"foo\")\nhq$show()\n#> Next item is at index 1 \n#> 1: 5\n#> 2: 6\n#> 3: foo\nhq$remove()\n#> [1] 5\nhq$show()\n#> Next item is at index 2 \n#> 1: 5\n#> 2: 6\n#> 3: foo\nhq$remove()\n#> [1] 6\nSuperclass methods can be called with super$xx(). The CountingQueue (example below) keeps a count of the total number of objects that have ever been added to the queue. It does this by overriding the add() method – it increments a counter and then calls the superclass’s add() method, with super$add(x):\n        CountingQueue <- R6Class(\"CountingQueue\",\n                                 inherit = Queue,\n                                 public = list(\n                                         add = function(x) {\n                                                 private$total <<- private$total + 1\n                                                 super$add(x)\n                                         },\n                                         get_total = function() private$total\n                                 ),\n                                 private = list(\n                                         total = 0\n                                 )\n        )\n\ncq <- CountingQueue$new(\"x\", \"y\")\ncq$get_total()\n#> [1] 2\ncq$add(\"z\")\ncq$remove()\n#> [1] \"x\"\ncq$remove()\n#> [1] \"y\"\ncq$get_total()\n#> [1] 3\nFields containing reference objects\n\nIf your R6 class contains any fields that also have reference semantics (e.g., other R6 objects, and environments), those fields should be populated in the initialize method. If the field set to the reference object directly in the class definition, that object will be shared across all instances of the R6 objects. Here’s an example:\n        SimpleClass <- R6Class(\"SimpleClass\",\n                               public = list(x = NULL)\n        )\n\nSharedField <- R6Class(\"SharedField\",\n                       public = list(\n                               e = SimpleClass$new()\n                       )\n)\n\ns1 <- SharedField$new()\ns1$e$x <- 1\n\ns2 <- SharedField$new()\ns2$e$x <- 2\n\n# Changing s2$e$x has changed the value of s1$e$x\ns1$e$x\n#> [1] 2\nTo avoid this, populate the field in the initialize method:\n        NonSharedField <- R6Class(\"NonSharedField\",\n                                  public = list(\n                                          e = NULL,\n                                          initialize = function() e <<- SimpleClass$new()\n                                  )\n        )\n\nn1 <- NonSharedField$new()\nn1$e$x <- 1\n\nn2 <- NonSharedField$new()\nn2$e$x <- 2\n\n# n2$e$x does not affect n1$e$x\nn1$e$x\n#> [1] 1\nPortable and non-portable classes\n\nIn R6 version 1.0.1, the default was to create non-portable classes. In subsequent versions, the default is to create portable classes. The two most noticeable differences are that portable classes:\n        Support inheritance across different packages. Non-portable classes do not do this very well.\nAlways require the use of self and private to access members, as in self$x and private$y. Non-portable classes can access these members with just x and y, and do assignment to these members with the <<- operator.\nThe implementation of the first point is such that it makes the second point necessary.\nUsing self and <<-\n        \n        With reference classes, you can access the field without self, and assign to fields using <<-. For example:\n        RC <- setRefClass(\"RC\",\n                          fields = list(x = 'ANY'),\n                          methods = list(\n                                  getx = function() x,\n                                  setx = function(value) x <<- value\n                          )\n        )\n\nrc <- RC$new()\nrc$setx(10)\nrc$getx()\n#> [1] 10\nThe same is true for non-portable R6 classes:\n        NP <- R6Class(\"NP\",\n                      portable = FALSE,\n                      public = list(\n                              x = NA,\n                              getx = function() x,\n                              setx = function(value) x <<- value\n                      )\n        )\n\nnp <- NP$new()\nnp$setx(10)\nnp$getx()\n#> [1] 10\nBut for portable R6 classes (this is the default), you must use self and/or private, and <<- assignment doesn’t work – unless you use self, of course:\n        P <- R6Class(\"P\",\n                     portable = TRUE,  # This is default\n                     public = list(\n                             x = NA,\n                             getx = function() self$x,\n                             setx = function(value) self$x <- value\n                     )\n        )\n\np <- P$new()\np$setx(10)\np$getx()\n#> [1] 10\nFor more information, see the Portable vignette.\nOther topics\n\nAdding members to an existing class\n\nIt is sometimes useful to add members to a class after the class has already been created. This can be done using the $set() method on the generator object.\nSimple <- R6Class(\"Simple\",\n                  public = list(\n                          x = 1,\n                          getx = function() x\n                          ",
    "created" : 1448875314847.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1025365398",
    "id" : "3AD2456B",
    "lastKnownWriteTime" : 1445998105,
    "path" : "D:/Git/stock/oop_R6.R",
    "project_path" : "oop_R6.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}