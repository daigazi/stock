{
    "contents" : "\n# base type【基本类型】\nf=function(x){}\ntypeof(f) #函数的类型是closure\ntypeof(sum) #原始函数 primitive function 是builtin\nformals(sum) #原始函数，底层是用C语言写的\nformals(f) #非原始函数\nf #可以看到源代码\n\na=c(1);b=list();e=new.env();df=data.frame(matrix(NA,3,2));fa=factor(c(\"f\",\"m\"))\ntypeof(a) #double\ntypeof(b)  #list\ntypeof(e)   #environment\ntypeof(df) #list\n\n\n# S3类型\na=c(1);b=list();e=new.env();df=data.frame(matrix(NA,3,2));fa=factor(c(\"f\",\"m\"))\nlibrary(pryr)\notype(df)  #S3\notype(a)   #base\notype(b)   #base\notype(e)   #base\notype(f)   #base\notype(sum) #base\notype(fa)  #S3\n\n#总结之：向量、列表、环境、函数是基本类型；数据框和因子是S3类型\n\nmean\nftype(mean) #pryr::ftype\nmethods(\"mean\")\nmethods(\"sum\") #no methods were found ,因为sum是原始函数，底层用C语言写，\n                #是内部泛型函数（internal generics ，?internal generics）\n\n#在S3中，方法（methods）属于函数，即所谓的泛型函数（generic functions），\n#S3的方法不属于对象（objects)或者类(classes),如C#语言是先定义类，给类\n#加属性和方法，初始化对象后，对象就可以使用类的方法了。泛型函数，如mean，\n#当给你一个类后，如dataf.frame，mena泛函就会在mean.Date     mean.default  \n#mean.difftime mean.POSIXct  mean.POSIXlt 这几个函数中寻找适合的函数，\n#本例中就找到mean.default;如果是给定POSIXlt类，就寻找到mean.POSIXlt\n\nftype(t.data.frame) #t()函数的方法t.data.frame使用在data frame类型上\n#t.data.frame这样的命名不好的原因有：1、大部分的现代编程风格指南都不鼓励使用.\n#2、容易引起混淆，如t.data.frame到底是方法t.data还是t。\nmethods(class = \"ts\")\nmean   #泛型函数，看不到源代码\n#[1] mean.Date     mean.default  mean.difftime mean.POSIXct  mean.POSIXlt\nmean.POSIXct #方法，可以源代码\nmean.default #方法，可以看到源代码\n#advanced R中讲到大部分的S3方法都不可见\nmethods(class = \"ts\") #查看ts类的方法\n# [1] [.ts*            [<-.ts*          aggregate.ts     as.data.frame.ts cbind.ts*       \n# [6] cycle.ts*        diff.ts*         diffinv.ts*      kernapply.ts*    lines.ts*       \n# [11] monthplot.ts*    na.omit.ts*      Ops.ts*          plot.ts          print.ts*       \n# [16] t.ts*            time.ts*         window.ts*       window<-.ts* \n#t.ts*  中的*表示函数是不可见源代码的（Non-visible functions are asterisked）\ngetS3method(f = \"aggregate\",class = \"ts\")  #查看aggregate.ts的源代码\ngetS3method(f = \"na.omit\",class = \"ts\")  #查看na.omit.ts的源代码\ngetS3method(f = \"cycle\",class = \"ts\")  #查看na.omit.ts的源代码\n#或者用getAnywhere()来看源代码\ngetAnywhere(\"cycle.ts\")\n##定义S3类和创建对象\n\ndai=structure(list(),class=\"dai\") #一步创建并设置类\nclass(dai);dai\n#分两步，第一先创建，再设定类\ndai=list()\nclass(dai)=\"dai\";dai\n#You can also turn functions into S3 objects. Other base types are either rarely \n#seen in R, or have unusual semantics that don’t work well with attributes.@advance R\n#有什么问题呢\n\n#对于因子，能否设置类呢？\ndai=factor(c(\"f\",\"m\"))\nclass(dai)=\"dai\"\nclass(dai);dai \n#对于数据框，能否设置类呢？\ndai=data.frame(a=1:2,b=2:1)\nclass(dai)=\"dai\"\nclass(dai);dai \n#对于函数，能否设置类呢？\ndai=function(x){print(\"函数变成类\")}\nclass(dai)=\"dai\"\nclass(dai);dai \ngazi=c()\nclass(gazi)=\"dai\" #Error in class(gazi) = \"dai\" : attempt to set an attribute on NULL\n\ngazi=function(){}\nclass(gazi)=\"dai\" #没错，可以通过\n\ninherits(x = dai,what = \"dai\") #是否继承自指定的类\n## Dobson (1990) Page 93: Randomized Controlled Trial :\ncounts <- c(18,17,15,20,10,20,25,13,12)\noutcome <- gl(3,1,9)\ntreatment <- gl(3,3)\nprint(d.AD <- data.frame(treatment, outcome, counts))\nglm.D93 <- glm(counts ~ outcome + treatment, family = poisson())\nclass(glm(glm.D93)) #\"glm\" \"lm\" ，说明S3对象的类可以继承自多个类\n\n\n#大部分S3类提供一个构造函数\ndai=function(x){\n        if(!is.funtion(x)){stop(\"X must be function\")}\n        structure(function(x){print(\"构造函数\")})\n}\ngazi=function(){}\nclass(gazi)=\"dai\" #没错，可以通过\n\n##创建新的方法和泛型函数\n#新增一个泛型函数，需要使用UseMethod(),UseMethod()函数有两个参数，一个是泛型函数\n#的名字，另一个是方法分派的参数。如果你省略掉第二个参数，那么它将分配到函数的第\n#一个函数。 不需要对 UseMethod()传递任何泛型函数的参数，并且你也不应该这样做。 \n#UseMethod()会使用所谓的\"黑魔法\"来找到它们本身。\n\nf=function(x) UseMethod(\"f\") #创建泛型函数\nf.dai=function(x) \"Class dai\"  #方法函数！泛型函数如果没有方法函数就不可用的\ndai=function(x){\n        if(!is.funtion(x)){stop(\"X must be function\")}\n        structure(function(x){print(\"构造函数\")})\n}\ngazi=function(){}\nclass(gazi)=\"dai\" #没错，可以通过\nclass(gazi)\nf(gazi)\n#新增一个方法到现有的泛型函数，如mean\nmean.dai=function(x)\"dai\"\nmean(gazi)\n\n5 S3对象的继承关系\n\n# S3对象有一种非常简单的继承方式，用NextMethod()函数来实现。\n# \n# 定义一个 node泛型函数\n\n\n node <- function(x) UseMethod(\"node\",x)\n#等于node <- function(x) UseMethod(\"node\")\n node.default <- function(x) \"Default node\"\n\n# father函数\n node.father <- function(x) c(\"father\")\n\n# son函数，通过NextMethod()函数指向father函数\n node.son <- function(x) c(\"son\", NextMethod())\n\n# 定义n1\n n1 <- structure(1, class = c(\"father\"))\n# 在node函数中传入n1，执行node.father()函数\n node(n1)\n#[1] \"father\"\n\n# 定义n2，设置class属性为两个\n n2 <- structure(1, class = c(\"son\", \"father\"))\n# 在node函数中传入n2，执行node.son()函数和node.father()函数\n node(n2)\n#[1] \"son\"    \"father\"\n# 通过对node()函数传入n2的参数，node.son()先被执行，然后通过NextMethod()函数继续执\n# 行了node.father()函数。这样其实就模拟了，子函数调用父函数的过程，实现了面向对象\n# 编程中的继承。\n\n# Read the source code for t() and t.test() and confirm that t.test() is an S3 \n#generic and not an S3 method. What happens if you create an object with class\n#test and call t() with it?\nrm(list=ls())\nstructure(list(),class=\"test\")\na=list(x=1,y=2)\nclass(a)=\"test\"\nt(a)\nt.test(a)\n\n\n\nrm(list=ls())\ny <- 1 \ng <- function(x) { \n        y <- 2 \n        UseMethod(\"g\") \n} \ng.numeric <- function(x) y \ng(10)  #返回2\nh <- function(x) { \n        x <- 10 \n        UseMethod(\"h\") \n} \nh.character <- function(x) paste(\"char\", x) \nh.numeric <- function(x) paste(\"num\", x) \nh(\"a\")  #返回\"char a\"\n\n\n\nf <- function() 1 \ng <- function() 2 \nclass(g) <- \"function\" \nclass(f) \nclass(g) \nlength.function <- function(x) \"function\" \nlength(f) \nlength(g)",
    "created" : 1448875280398.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3043699046",
    "id" : "7326EC2A",
    "lastKnownWriteTime" : 1445936696,
    "path" : "D:/Git/stock/oop_S3.R",
    "project_path" : "oop_S3.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}