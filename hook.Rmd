
一共有两类钩子（hook）函数：代码段钩子（chunk hooks）和输出钩子（output hooks）。

钩子这个名字听起来很怪，不过其实它就是一个特殊函数而已，在某些情况下会被触发执行。
```{r,eval=TRUE,echo=FALSE,warning=FALSE}
library(knitr)
knitr::opts_chunk$set(out.width=30)
```

代码段钩子对应着自定义的代码段选项，也就是所有默认选项之外的选项，注意knitr的代

码段选项名称没有限制，你可以写任意合法取值的选项。代码段钩子函数可以通过

knit_hooks对象设定。下面举个例子说明新选项和钩子函数如何关联。我们先构造一个新钩

子函数叫par：
```{r,eval=FALSE}
knit_hooks$set(par = function(before, options, envir) {
    # 运行代码前先设置图形边距参数
    if (before) 
        par(mar = c(4, 4, 4, 4))
})
```

```{r,eval=T,echo=FALSE}
knit_hooks$set(par = function(before, options, envir) {
    # 运行代码前先设置图形边距参数
    if (before) 
        par(mar = c(4, 4, 4, 4))
})
```

代码段钩子有固定的格式，它是一个有三个参数的函数，其中before是逻辑值，表示这个钩
子在代码段之前执行（TRUE）还是之后执行（FALSE），options是一个列表，装有所有当前
代码段的选项，envir是一个环境对象，是当前代码段执行的环境。代码段钩子设置好之后
，每当一个代码段被运行前后，knitr都会检查这个代码段是否有一个跟钩子函数同名的选
项，如果有且非空，那么就会运行钩子函数。

假设我们新造的一个选项叫par，它不是knitr自带的选项，且跟上面定义的钩子函数同名，
那么对下面这个代码段来说，它被执行之前，R会先用par()函数设置图形边距参数，因为这
是钩子函数定义要执行的任务：

```{r,par,eval=TRUE,echo=TRUE}
plot(1)
```


```{r,par1,eval=F,echo=TRUE,out.width=80}
{r,par,eval=F,echo=TRUE}
plot(1)
```

注意钩子函数被触发的条件是相应的选项取值非空，所以这里par取值TRUE或FALSE或123都无
所谓。代码段钩子让我们可以把常见的次要任务抽象出来，用一个代码段选项去控制它们的
执行。比如上面设定图形边距就是一个非常常见的任务，但要是把这样的代码在每个代码段
中的都写一遍的话，就太啰嗦了，而且重复敲代码是大忌！每当你想复制粘贴一段代码的时
候都要三思，我真的不需要想办法把这段代码抽象出去吗？

输出钩子用来装裱输出，knitr的透明性也体现在这一类钩子上，它可以把R的各类输出都交
给用户，让用户决定怎么处理这些输出。所有可能的输出有：源代码、普通文本、警告消息
、普通消息、错误消息和图形。每一种有一个对应的钩子函数，这些函数接收R的输出，以
一定的形式包装它们，再返回输出来。以源代码为例，它的钩子名为source，如果我们定义：


<<source-hook>>=
knit_hooks$set(source = function(x, options) {
  paste('\\begin{myEnvironment}', x, '\\end{myEnvironment}')
})
@

那么在输出的时候所有R源代码都会被放在myEnvironment环境中（当然，你得事先定义好这
个环境，不然LaTeX会报错）。钩子函数中，x是当前代码段的输出，options是所有选项的
一个列表。

由于我们可以自定义输出的格式，我们就可以任意装潢输出的外观，例如我们可以把错误消
息放在某个红色粗体环境中，把警告信息以斜体显示，等等。这个包已经自带了一系列预先
定义好的钩子函数，所以除非有特殊需要，通常不需要重定义输出钩子函数。

回到最开始的话题，Sweave的设计绑定了TeX，也就是它的输出只能装在TeX环境中，所以很
难移植到别的格式，一直以来，人们扩展Sweave的方式就是把那七八百行代码复制一遍，然
后把里面定义死的输出修改为另一种输出，这是糟糕透顶的扩展方式，因为也许下个月R就
修改了源代码，但扩展者可能就跟不上官方的更改了；pgfSweave和cacheSweave以及一系
列基于Sweave扩展的附加包就这样被Sweave带进了一个大坑，我就是目睹了这个坑爹的过
程。程序的扩展性在设计初期一定要考虑清楚，但很多情况下，我们内心总是被一个微小
的声音不断规劝：想那么多干什么，搞定这件事就好了！为了搞定一件事而失去推广性
，这是开发者的大悲剧。

至此，我们知道了如何把R代码混入文档，如何标记R代码，有哪些基本选项，如何输出
图形，使用缓存使文档编译加速以及定制钩子函数。下面我们介绍两套方便的编辑器，
让knitr的操作更方便。